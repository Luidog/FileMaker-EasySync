/**
 * =====================================
 * #Remove ( parameters ; removeParameters )
 *
 * RETURNS:
 *		A #-format dictionary based on parameters, but with all values named in
 *		removeParameters removed.
 *
 * PARAMETERS:
 *		parameters: A string of name-value pairs
 *		removeParameters: The names of name-value pairs to remove.
 *
 * DEPENDENCIES: none
 *
 * NOTES:
 *		This is a recursive function.
 *
 * HISTORY:
 *		MODIFIED on 2013-12-24 by Jeremy Bante <http://scr.im/jbante> to improve
 *		efficiency.
 *		MODIFIED on 2013-12-23 by John Jones
 *		<john.christopher@alumn.virginia.edu> to use Middle/Position instead of
 *		GetValue.
 *		MODIFIED on 2013-03-15 by Daniel Smith <http://scr.im/dansmith> to add
 *		trailing return if it doesn't exist.
 *		MODIFIED on 2013-01-08 by Jeremy Bante <http://scr.im/jbante> to extend
 *		the function to remove multiple names from a return-delimited list.
 *		CREATED on 2012-12-20 by Daniel Smith <http://scr.im/dansmith>
 * =====================================
 */

Case (
	/* Step 0, set-up */
	not $#Remove.step ;
		Let ( [
			~empty = IsEmpty ( parameters ) or IsEmpty ( removeParameters ) ;
			removeParameters =	// add "$" prefix for matching
				Substitute ( ¶ & removeParameters ; ¶ ; "¶$" ) ;
			removeParameters =	// add "$$" prefix for backwards-compatibility
				removeParameters
				& Substitute ( removeParameters ; ¶ ; "¶$" )
				& ¶ ;
			$#Remove.length = Length ( parameters ) ;
			$#Remove.step = If ( ~empty ; -1 ; /* Else */ 1 )
		] ;
			#Remove ( parameters ; removeParameters )
		) ;

	/* Step 1, check each parameter */
	$#Remove.step = 1 ;
		Let ( [
			~start = $#Remove.end + 1 ;
			$#Remove.end = Position ( parameters ; ¶ ; ~start ; 1 ) ;
			~endOfList = $#Remove.end = 0 ;
			~length =
				If ( ~endOfList ;
					$#Remove.length + 1 ;
					/* Else */ $#Remove.end
				)
				- ~start ;
			~pair = Middle ( parameters ; ~start ; ~length ) ;
			~name = Left ( ~pair ; Position ( ~pair ; " = " ; 1 ; 1 ) - 1 ) ;
			~include =	// only include if ~name is not in removeParameters
				not IsEmpty ( ~name )
				and Position ( removeParameters ; ¶ & ~name & ¶ ; 1 ; 1 ) = 0 ;
			$#Remove.result =
				$#Remove.result
				& If ( ~include ; ~pair & ¶ ) ;

			~endOfList = ~endOfList or $#Remove.end ≥ $#Remove.length ;
			$#Remove.step =
				If ( ~endOfList ; $#Remove.step + 1 ; /* Else */ $#Remove.step )
		] ;
			#Remove ( parameters ; removeParameters )
		) ;

	/* Step 2, clean-up and return result */
	$#Remove.step = 2 or $#Remove.step = -1 ;
		Let ( [
			~empty = $#Remove.step = -1 ;
			~result = If ( ~empty ; parameters ; /* Else */ $#Remove.result ) ;

			// purge variables
			$#Remove.end = "" ;
			$#Remove.length = "" ;
			$#Remove.result = "" ;
			$#Remove.step = ""
		] ;
			~result
		)
)

---
CustomFunction:
  id: '15'
  functionArity: '2'
  visible: 'True'
  parameters: parameters;removeParameters
  name: '#Remove'
  Calculation: "/**\n * =====================================\n * #Remove ( parameters
    ; removeParameters )\n *\n * RETURNS:\n *\t\tA #-format dictionary based on parameters,
    but with all values named in\n *\t\tremoveParameters removed.\n *\n * PARAMETERS:\n
    *\t\tparameters: A string of name-value pairs\n *\t\tremoveParameters: The names
    of name-value pairs to remove.\n *\n * DEPENDENCIES: none\n *\n * NOTES:\n *\t\tThis
    is a recursive function.\n *\n * HISTORY:\n *\t\tMODIFIED on 2013-12-24 by Jeremy
    Bante <http://scr.im/jbante> to improve\n *\t\tefficiency.\n *\t\tMODIFIED on
    2013-12-23 by John Jones\n *\t\t<john.christopher@alumn.virginia.edu> to use Middle/Position
    instead of\n *\t\tGetValue.\n *\t\tMODIFIED on 2013-03-15 by Daniel Smith <http://scr.im/dansmith>
    to add\n *\t\ttrailing return if it doesn't exist.\n *\t\tMODIFIED on 2013-01-08
    by Jeremy Bante <http://scr.im/jbante> to extend\n *\t\tthe function to remove
    multiple names from a return-delimited list.\n *\t\tCREATED on 2012-12-20 by Daniel
    Smith <http://scr.im/dansmith>\n * =====================================\n */\n\nCase
    (\n\t/* Step 0, set-up */\n\tnot $#Remove.step ;\n\t\tLet ( [\n\t\t\t~empty =
    IsEmpty ( parameters ) or IsEmpty ( removeParameters ) ;\n\t\t\tremoveParameters
    =\t// add \"$\" prefix for matching\n\t\t\t\tSubstitute ( ¶ & removeParameters
    ; ¶ ; \"¶$\" ) ;\n\t\t\tremoveParameters =\t// add \"$$\" prefix for backwards-compatibility\n\t\t\t\tremoveParameters\n\t\t\t\t&
    Substitute ( removeParameters ; ¶ ; \"¶$\" )\n\t\t\t\t& ¶ ;\n\t\t\t$#Remove.length
    = Length ( parameters ) ;\n\t\t\t$#Remove.step = If ( ~empty ; -1 ; /* Else */
    1 )\n\t\t] ;\n\t\t\t#Remove ( parameters ; removeParameters )\n\t\t) ;\n\n\t/*
    Step 1, check each parameter */\n\t$#Remove.step = 1 ;\n\t\tLet ( [\n\t\t\t~start
    = $#Remove.end + 1 ;\n\t\t\t$#Remove.end = Position ( parameters ; ¶ ; ~start
    ; 1 ) ;\n\t\t\t~endOfList = $#Remove.end = 0 ;\n\t\t\t~length =\n\t\t\t\tIf (
    ~endOfList ;\n\t\t\t\t\t$#Remove.length + 1 ;\n\t\t\t\t\t/* Else */ $#Remove.end\n\t\t\t\t)\n\t\t\t\t-
    ~start ;\n\t\t\t~pair = Middle ( parameters ; ~start ; ~length ) ;\n\t\t\t~name
    = Left ( ~pair ; Position ( ~pair ; \" = \" ; 1 ; 1 ) - 1 ) ;\n\t\t\t~include
    =\t// only include if ~name is not in removeParameters\n\t\t\t\tnot IsEmpty (
    ~name )\n\t\t\t\tand Position ( removeParameters ; ¶ & ~name & ¶ ; 1 ; 1 ) = 0
    ;\n\t\t\t$#Remove.result =\n\t\t\t\t$#Remove.result\n\t\t\t\t& If ( ~include ;
    ~pair & ¶ ) ;\n\n\t\t\t~endOfList = ~endOfList or $#Remove.end ≥ $#Remove.length
    ;\n\t\t\t$#Remove.step =\n\t\t\t\tIf ( ~endOfList ; $#Remove.step + 1 ; /* Else
    */ $#Remove.step )\n\t\t] ;\n\t\t\t#Remove ( parameters ; removeParameters )\n\t\t)
    ;\n\n\t/* Step 2, clean-up and return result */\n\t$#Remove.step = 2 or $#Remove.step
    = -1 ;\n\t\tLet ( [\n\t\t\t~empty = $#Remove.step = -1 ;\n\t\t\t~result = If (
    ~empty ; parameters ; /* Else */ $#Remove.result ) ;\n\n\t\t\t// purge variables\n\t\t\t$#Remove.end
    = \"\" ;\n\t\t\t$#Remove.length = \"\" ;\n\t\t\t$#Remove.result = \"\" ;\n\t\t\t$#Remove.step
    = \"\"\n\t\t] ;\n\t\t\t~result\n\t\t)\n)"
  DisplayCalculation:
    Chunk:
    - "/**\n * =====================================\n * #Remove ( parameters ; removeParameters
      )\n *\n * RETURNS:\n *\t\tA #-format dictionary based on parameters, but with
      all values named in\n *\t\tremoveParameters removed.\n *\n * PARAMETERS:\n *\t\tparameters:
      A string of name-value pairs\n *\t\tremoveParameters: The names of name-value
      pairs to remove.\n *\n * DEPENDENCIES: none\n *\n * NOTES:\n *\t\tThis is a
      recursive function.\n *\n * HISTORY:\n *\t\tMODIFIED on 2013-12-24 by Jeremy
      Bante <http://scr.im/jbante> to improve\n *\t\tefficiency.\n *\t\tMODIFIED on
      2013-12-23 by John Jones\n *\t\t<john.christopher@alumn.virginia.edu> to use
      Middle/Position instead of\n *\t\tGetValue.\n *\t\tMODIFIED on 2013-03-15 by
      Daniel Smith <http://scr.im/dansmith> to add\n *\t\ttrailing return if it doesn't
      exist.\n *\t\tMODIFIED on 2013-01-08 by Jeremy Bante <http://scr.im/jbante>
      to extend\n *\t\tthe function to remove multiple names from a return-delimited
      list.\n *\t\tCREATED on 2012-12-20 by Daniel Smith <http://scr.im/dansmith>\n
      * =====================================\n */\n\n"
    - Case
    - " (\n\t/* Step 0, set-up */\n\t"
    - not
    - " $#Remove.step ;\n\t\t"
    - Let
    - " ( [\n\t\t\t~empty = "
    - IsEmpty
    - ' ( parameters ) '
    - or
    - type: NoRef
      __content__: ' '
    - IsEmpty
    - " ( removeParameters ) ;\n\t\t\tremoveParameters =\t"
    - |
      // add "$" prefix for matching
    - type: NoRef
      __content__: "\t\t\t\t"
    - Substitute
    - " ( ¶ & removeParameters ; ¶ ; \"¶$\" ) ;\n\t\t\tremoveParameters =\t"
    - |
      // add "$$" prefix for backwards-compatibility
    - "\t\t\t\tremoveParameters\n\t\t\t\t& "
    - Substitute
    - " ( removeParameters ; ¶ ; \"¶$\" )\n\t\t\t\t& ¶ ;\n\t\t\t$#Remove.length = "
    - Length
    - " ( parameters ) ;\n\t\t\t$#Remove.step = "
    - If
    - " ( ~empty ; -1 ; /* Else */ 1 )\n\t\t] ;\n\t\t\t"
    - '#Remove'
    - " ( parameters ; removeParameters )\n\t\t) ;\n\n\t/* Step 1, check each parameter
      */\n\t$#Remove.step = 1 ;\n\t\t"
    - Let
    - " ( [\n\t\t\t~start = $#Remove.end + 1 ;\n\t\t\t$#Remove.end = "
    - Position
    - " ( parameters ; ¶ ; ~start ; 1 ) ;\n\t\t\t~endOfList = $#Remove.end = 0 ;\n\t\t\t~length
      =\n\t\t\t\t"
    - If
    - " ( ~endOfList ;\n\t\t\t\t\t$#Remove.length + 1 ;\n\t\t\t\t\t/* Else */ $#Remove.end\n\t\t\t\t)\n\t\t\t\t-
      ~start ;\n\t\t\t~pair = "
    - Middle
    - " ( parameters ; ~start ; ~length ) ;\n\t\t\t~name = "
    - Left
    - ' ( ~pair ; '
    - Position
    - " ( ~pair ; \" = \" ; 1 ; 1 ) - 1 ) ;\n\t\t\t~include =\t"
    - |
      // only include if ~name is not in removeParameters
    - type: NoRef
      __content__: "\t\t\t\t"
    - not
    - type: NoRef
      __content__: ' '
    - IsEmpty
    - " ( ~name )\n\t\t\t\t"
    - and
    - type: NoRef
      __content__: ' '
    - Position
    - " ( removeParameters ; ¶ & ~name & ¶ ; 1 ; 1 ) = 0 ;\n\t\t\t$#Remove.result
      =\n\t\t\t\t$#Remove.result\n\t\t\t\t& "
    - If
    - " ( ~include ; ~pair & ¶ ) ;\n\n\t\t\t~endOfList = ~endOfList "
    - or
    - " $#Remove.end ≥ $#Remove.length ;\n\t\t\t$#Remove.step =\n\t\t\t\t"
    - If
    - " ( ~endOfList ; $#Remove.step + 1 ; /* Else */ $#Remove.step )\n\t\t] ;\n\t\t\t"
    - '#Remove'
    - " ( parameters ; removeParameters )\n\t\t) ;\n\n\t/* Step 2, clean-up and return
      result */\n\t$#Remove.step = 2 "
    - or
    - " $#Remove.step = -1 ;\n\t\t"
    - Let
    - " ( [\n\t\t\t~empty = $#Remove.step = -1 ;\n\t\t\t~result = "
    - If
    - " ( ~empty ; parameters ; /* Else */ $#Remove.result ) ;\n\n\t\t\t"
    - |
      // purge variables
    - "\t\t\t$#Remove.end = \"\" ;\n\t\t\t$#Remove.length = \"\" ;\n\t\t\t$#Remove.result
      = \"\" ;\n\t\t\t$#Remove.step = \"\"\n\t\t] ;\n\t\t\t~result\n\t\t)\n)"
