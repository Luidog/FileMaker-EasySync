/**
 * =====================================
 * #Assign ( parameters )
 *
 * PURPOSE:
 *		Parses a Let dictionary of name-value parameters into a series of
 *		locally scoped $variables.
 *
 * RETURNS:
 *		True (1) when parameters is a valid set of name-value pairs (which
 *		includes the empty string); False (0) otherwise.
 *		If False (0), the error code will be saved to: $#Assign.error
 *
 * PARAMETERS:
 *		parameters: A Let format dictionary, such as produced by the
 *		# ( name ; value ) function.
 *
 * DEPENDENCIES: none
 *
 * NOTES:
 *		Notes go here
 *
 * HISTORY:
 *		MODIFIED on 2013-03-15 by Daniel Smith <http://scr.im/dansmith> to
 *		update documentation to match functions actual return value.
 *		MODIFIED on 2012-11-28 by Jeremy Bante <http://scr.im/jbante> to support
 *		"$" prefix values as default.
 *		CREATED on 2012-11-11 by Jeremy Bante <http://scr.im/jbante>.
 * =====================================
 */

Let ( [
        ~exp = "Let ( [¶"
			& Substitute (	// convert global variables to let variables ie get rid of all $'s
				¶ & parameter;
				["¶$$"; "¶$"];
                                ["¶$" ; "¶"]
			)
			& "¶~ = \"\" ];" & function  & ")";



	~error =

		EvaluationError ( Evaluate ( ~exp
					) )
];

Case(
    IsValidExpression ( ~exp ) ; Evaluate(~exp);
     Let ( $#Assign.error = EvaluationError ( Evaluate(~exp) ); "?" )
)
)

---
CustomFunction:
  id: '10'
  functionArity: '2'
  visible: 'True'
  parameters: function;parameter
  name: '#FunctionCall'
  Calculation: "/**\n * =====================================\n * #Assign ( parameters
    )\n *\n * PURPOSE:\n *\t\tParses a Let dictionary of name-value parameters into
    a series of\n *\t\tlocally scoped $variables.\n *\n * RETURNS:\n *\t\tTrue (1)
    when parameters is a valid set of name-value pairs (which\n *\t\tincludes the
    empty string); False (0) otherwise.\n *\t\tIf False (0), the error code will be
    saved to: $#Assign.error\n *\n * PARAMETERS:\n *\t\tparameters: A Let format dictionary,
    such as produced by the\n *\t\t# ( name ; value ) function.\n *\n * DEPENDENCIES:
    none\n *\n * NOTES:\n *\t\tNotes go here\n *\n * HISTORY:\n *\t\tMODIFIED on 2013-03-15
    by Daniel Smith <http://scr.im/dansmith> to\n *\t\tupdate documentation to match
    functions actual return value.\n *\t\tMODIFIED on 2012-11-28 by Jeremy Bante <http://scr.im/jbante>
    to support\n *\t\t\"$\" prefix values as default.\n *\t\tCREATED on 2012-11-11
    by Jeremy Bante <http://scr.im/jbante>.\n * =====================================\n
    */\n\nLet ( [\n        ~exp = \"Let ( [¶\"\n\t\t\t& Substitute (\t// convert global
    variables to let variables ie get rid of all $'s\n\t\t\t\t¶ & parameter;\n\t\t\t\t[\"¶$$\";
    \"¶$\"];\n                                [\"¶$\" ; \"¶\"]\n\t\t\t)\n\t\t\t& \"¶~
    = \\\"\\\" ];\" & function  & \")\";\n\n\n\n\t~error =\n\n\t\tEvaluationError
    ( Evaluate ( ~exp\n\t\t\t\t\t) )\n];\n\nCase(\n    IsValidExpression ( ~exp )
    ; Evaluate(~exp);\n     Let ( $#Assign.error = EvaluationError ( Evaluate(~exp)
    ); \"?\" )\n)\n)"
  DisplayCalculation:
    Chunk:
    - "/**\n * =====================================\n * #Assign ( parameters )\n
      *\n * PURPOSE:\n *\t\tParses a Let dictionary of name-value parameters into
      a series of\n *\t\tlocally scoped $variables.\n *\n * RETURNS:\n *\t\tTrue (1)
      when parameters is a valid set of name-value pairs (which\n *\t\tincludes the
      empty string); False (0) otherwise.\n *\t\tIf False (0), the error code will
      be saved to: $#Assign.error\n *\n * PARAMETERS:\n *\t\tparameters: A Let format
      dictionary, such as produced by the\n *\t\t# ( name ; value ) function.\n *\n
      * DEPENDENCIES: none\n *\n * NOTES:\n *\t\tNotes go here\n *\n * HISTORY:\n
      *\t\tMODIFIED on 2013-03-15 by Daniel Smith <http://scr.im/dansmith> to\n *\t\tupdate
      documentation to match functions actual return value.\n *\t\tMODIFIED on 2012-11-28
      by Jeremy Bante <http://scr.im/jbante> to support\n *\t\t\"$\" prefix values
      as default.\n *\t\tCREATED on 2012-11-11 by Jeremy Bante <http://scr.im/jbante>.\n
      * =====================================\n */\n\n"
    - Let
    - " ( [\n        ~exp = \"Let ( [¶\"\n\t\t\t& "
    - Substitute
    - " (\t"
    - |
      // convert global variables to let variables ie get rid of all $'s
    - "\t\t\t\t¶ & parameter;\n\t\t\t\t[\"¶$$\"; \"¶$\"];\n                                [\"¶$\"
      ; \"¶\"]\n\t\t\t)\n\t\t\t& \"¶~ = \\\"\\\" ];\" & function  & \")\";\n\n\n\n\t~error
      =\n\n\t\t"
    - EvaluationError
    - ' ( '
    - Evaluate
    - " ( ~exp\n\t\t\t\t\t) )\n];\n\n"
    - Case
    - "(\n    "
    - IsValidExpression
    - ' ( ~exp ) ; '
    - Evaluate
    - "(~exp);\n     "
    - Let
    - ' ( $#Assign.error = '
    - EvaluationError
    - ' ( '
    - Evaluate
    - |-
      (~exp) ); "?" )
      )
      )
